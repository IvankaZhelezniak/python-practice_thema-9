# обробка винятків у Python здійснюється за допомогою конструкції try/except. 
# Це дозволяє програмі продовжувати виконання, навіть якщо виникає помилка. 
# Ви можете специфікувати різні типи винятків, які хочете обробити, або використовувати загальний виняток, щоб перехопити будь-яку помилку.

try:
    # Код, який може викликати виняток
    result = 10 / 0
except ZeroDivisionError:
    # Обробка винятку ділення на нуль
    print("Ділення на нуль неможливе!")
except Exception as e:
    # Обробка будь-якого іншого винятку
    print(f"Виникла помилка: {e}")
else:
    # Виконується, якщо виняток не був викликаний
    print("Все пройшло успішно!")
finally:
    # Виконується завжди, незалежно від того, був виняток чи ні
    print("Блок finally завжди виконується.")

# У прикладі спочатку виконується код у блоку try. Якщо під час виконання коду виникає помилка ділення на нуль ZeroDivisionError, 
# то виконується код у відповідному блоку except. Якщо виникає будь-яка інша помилка, 
# вона обробляється в наступному блоку except, де Exception є базовим класом для всіх вбудованих винятків. 
# Блок else виконується, якщо в блоку try не виникає жодного винятку, а блок finally виконується завжди, незалежно від того, 
# був виняток чи не було, що робить його ідеальним для очищення ресурсів, наприклад, закриття файлів.

# Коли ж ви пишете свій застосунок вам може знадобитися створити свої власні винятки, 
# щоб обробляти їх на рівні вище. Створення власних винятків у Python дозволяє краще керувати помилками у вашому коді, 
# роблячи його більш гнучким та зрозумілим для інших розробників. 
# Для цього вам потрібно визначити клас винятку, який наслідується від класу Exception або одного з його підкласів.

# Створити власний виняток досить легко:
class MyCustomError(Exception):
    """Базовий клас для власних винятків"""
    pass

# Тут MyCustomError є власним класом винятку, який ви можете використовувати для викидання помилок, специфічних для вашої програми.

# Визначимо власний клас винятку для обробки помилок, пов'язаних з перевіркою віку особи. 

# Це може бути корисно в ситуаціях, де потрібно переконатися, що особа досягла певного віку, 
# наприклад, для реєстрації на сайті або при купівлі певних товарів. 
# Перш за все, ми повинні створити власний клас винятку та назвати його відповідно - AgeVerificationError, 
# який наслідується від базового класу Exception. Цей клас буде використовуватися для викидання помилки, 
# коли вік особи не задовольняє встановлені умови

# Створимо функцію verify_age, яка приймає вік як аргумент і перевіряє, чи є особа дорослою (наприклад, 18 років або старше). 
# Якщо вік менший за 18, функція повинна викинути виняток AgeVerificationError.

# Визначення власного класу винятку
class AgeVerificationError(Exception):
    def __init__(self, message="Вік не задовольняє мінімальній вимозі"):
        self.message = message
        super().__init__(self.message)

# Функція для перевірки віку
def verify_age(age: int):
    if age < 18:
        raise AgeVerificationError("Вік особи менший за 18 років")

if __name__ == "__main__":
    # Обробка винятку
    try:
        verify_age(16)  # Змініть вік для різних результатів
    except AgeVerificationError as e:
        print(f"Виняток: {e}")
    else:
        print("Вік перевірено, особа доросла.")

# Ми використали блок try/except для обробки винятку, викинутого функцією verify_age. 
# Якщо ми запустимо код то виклик функції verify_age з віком меншим за 18, призведе до нашого винятку AgeVerificationError, 
# і буде виведено відповідне повідомлення.


# Наступний приклад, ви очікуєте, що користувач повинен ввести ім'я, 
# і це ім'я не повинно бути коротшим двох символів і починатися з великої літери. 
# Ми можемо створити власні винятки, які буде викликатися, якщо введення користувача не пройшло цю перевірку. 
# Тоді будь-який код, який викликатиме цю функцію, зможе коректно обробити цей конкретний випадок.

class NameTooShortError(Exception):
    pass

class NameStartsFromLowError(Exception):
    pass

def enter_name():
    name = input("Enter name: ")
    if len(name) < 3:
        raise NameTooShortError("Name is too short, need more than 2 symbols")
    if not name[0].isupper():
        raise NameStartsFromLowError("Name should start from capital letter")
    return name

if __name__ == "__main__":
    try:
        name = enter_name()
        print(f"Hello, {name}")
    except (NameTooShortError, NameStartsFromLowError) as e:
        print(e)

# Ми визначили два власних класу винятків: NameTooShortError та NameStartsFromLowError. 
# Вони наслідуються від класу Exception і призначені для сигналізації про специфічні помилки при введенні імені: 
# коли ім'я занадто коротке або починається не з великої літери.

# Функція enter_name просить у користувача ввести ім'я. Після введення імені функція перевіряє його на відповідність двом умовам: 
# ім'я повинне бути довшим за два символи та починатися з великої літери. 
# Якщо ім'я не відповідає одній з цих умов, функція викидує відповідний виняток за допомогою оператора raise. 
# У разі успішної перевірки функція повертає введене ім'я.

# Коли програма виконується, вона спочатку викликає функцію enter_name всередині блоку try. 
# Якщо під час виконання функції піднімається виняток (або NameTooShortError, або NameStartsFromLowError), 
# він обробляється в блоку except, де виводиться повідомлення про помилку. Якщо ж ім'я було введено правильно 
# і не викликало винятків, програма виводить привітання з цим іменем.


# Загалом така структура власних винятків дозволяє гнучко обробляти помилки введення, 
# не перериваючи виконання програми при її виникненні. Та сповіщати користувача, що саме трапилося.